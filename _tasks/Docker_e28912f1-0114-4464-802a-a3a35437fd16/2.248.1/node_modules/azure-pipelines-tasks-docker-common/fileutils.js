"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findDockerFile = exports.writeFileSync = void 0;
const fs = require("fs");
const path = require("path");
const tl = require("azure-pipelines-task-lib/task");
tl.setResourcePath(path.join(__dirname, 'module.json'), true);
// http://www.daveeddy.com/2013/03/26/synchronous-file-io-in-nodejs/
// We needed a true Sync file write for config file
function writeFileSync(filePath, data) {
    try {
        const fd = fs.openSync(filePath, 'w');
        var bitesWritten = fs.writeSync(fd, data);
        fs.fsyncSync(fd);
        tl.debug(tl.loc("FileContentSynced", data));
        fs.closeSync(fd);
        return bitesWritten;
    }
    catch (e) {
        tl.error(tl.loc('CantWriteDataToFile', filePath, e));
        throw e;
    }
}
exports.writeFileSync = writeFileSync;
function findDockerFile(dockerfilepath) {
    if (dockerfilepath.indexOf('*') >= 0 || dockerfilepath.indexOf('?') >= 0) {
        tl.debug(tl.loc('ContainerPatternFound'));
        let workingDirectory = tl.getVariable('System.DefaultWorkingDirectory');
        let allFiles = tl.find(workingDirectory);
        let matchingResultsFiles = tl.match(allFiles, dockerfilepath, workingDirectory, { matchBase: true });
        if (!matchingResultsFiles || matchingResultsFiles.length == 0) {
            throw new Error(tl.loc('ContainerDockerFileNotFound', dockerfilepath));
        }
        return matchingResultsFiles[0];
    }
    else {
        tl.debug(tl.loc('ContainerPatternNotFound'));
        return dockerfilepath;
    }
}
exports.findDockerFile = findDockerFile;
