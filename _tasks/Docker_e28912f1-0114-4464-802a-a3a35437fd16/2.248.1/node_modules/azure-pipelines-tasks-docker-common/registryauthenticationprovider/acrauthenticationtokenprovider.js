"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Q = require("q");
const azure_arm_common_1 = require("azure-pipelines-tasks-azure-arm-rest/azure-arm-common");
const azure_arm_endpoint_1 = require("azure-pipelines-tasks-azure-arm-rest/azure-arm-endpoint");
const webClient = require("azure-pipelines-tasks-azure-arm-rest/webClient");
const tl = require("azure-pipelines-task-lib/task");
const authenticationtokenprovider_1 = require("./authenticationtokenprovider");
const registryauthenticationtoken_1 = require("./registryauthenticationtoken");
class ACRAuthenticationTokenProvider extends authenticationtokenprovider_1.default {
    constructor(endpointName, registerNameValue) {
        super();
        if (endpointName && registerNameValue) {
            try {
                tl.debug("Reading the acr registry in old versions");
                var obj = JSON.parse(registerNameValue);
                this.registryURL = obj.loginServer;
                this.acrFragmentUrl = obj.id;
            }
            catch (e) {
                tl.debug("Reading the acr registry in kubernetesV1");
                this.registryURL = registerNameValue;
            }
            this.endpointName = endpointName;
        }
    }
    getAuthenticationToken() {
        if (this.registryURL && this.endpointName) {
            return new registryauthenticationtoken_1.default(tl.getEndpointAuthorizationParameter(this.endpointName, 'serviceprincipalid', true), tl.getEndpointAuthorizationParameter(this.endpointName, 'serviceprincipalkey', true), this.registryURL, "ServicePrincipal@AzureRM", this.getXMetaSourceClient());
        }
        return null;
    }
    getToken() {
        return __awaiter(this, void 0, void 0, function* () {
            let authType;
            try {
                tl.debug("Attempting to get endpoint authorization scheme...");
                authType = tl.getEndpointAuthorizationScheme(this.endpointName, false);
            }
            catch (error) {
                tl.debug("Failed to get endpoint authorization scheme.");
            }
            if (!authType) {
                try {
                    tl.debug("Attempting to get endpoint authorization scheme as an authorization parameter...");
                    authType = tl.getEndpointAuthorizationParameter(this.endpointName, "scheme", false);
                }
                catch (error) {
                    tl.debug("Failed to get endpoint authorization scheme as an authorization parameter. Will default authorization scheme to ServicePrincipal.");
                    authType = "ServicePrincipal";
                }
            }
            if (authType == "ManagedServiceIdentity") {
                // Parameter 1: retryCount - the current retry count of the method to get the ACR token through MSI authentication
                // Parameter 2: timeToWait - the current time wait of the method to get the ACR token through MSI authentication
                return yield this._getMSIAuthenticationToken(0, 0);
            }
            else if (authType === 'WorkloadIdentityFederation') {
                const endpoint = yield new azure_arm_endpoint_1.AzureRMEndpoint(this.endpointName).getEndpoint();
                const aadToken = yield endpoint.applicationTokenCredentials.getToken();
                let acrToken = yield ACRAuthenticationTokenProvider._getACRToken(aadToken, this.endpointName, this.registryURL, 0, 0);
                return new registryauthenticationtoken_1.default("00000000-0000-0000-0000-000000000000", acrToken, this.registryURL, "WorkloadIdentityFederation@AzureRM", this.getXMetaSourceClient());
            }
            else {
                return this.getAuthenticationToken();
            }
        });
    }
    static _getACRToken(AADToken, endpointName, registryURL, retryCount, timeToWait) {
        tl.debug("Attempting to convert AAD Token to an ACR token");
        let deferred = Q.defer();
        let tenantID = tl.getEndpointAuthorizationParameter(endpointName, 'tenantid', true);
        let webRequest = new webClient.WebRequest();
        webRequest.method = "POST";
        const retryLimit = 5;
        webRequest.uri = `https://${registryURL}/oauth2/exchange`;
        webRequest.body = (`grant_type=access_token&service=${registryURL}&tenant=${tenantID}&access_token=${AADToken}`);
        webRequest.headers = {
            "Content-Type": "application/x-www-form-urlencoded"
        };
        webClient.sendRequest(webRequest).then((response) => {
            if (response.statusCode === 200) {
                deferred.resolve(response.body.refresh_token);
            }
            else if (response.statusCode == 429 || response.statusCode == 500) {
                if (retryCount < retryLimit) {
                    if (response.statusCode == 429) {
                        tl.debug("Too many requests were made to get ACR token. Retrying...");
                    }
                    else {
                        tl.debug("Internal server error occurred. Retrying...");
                    }
                    let waitedTime = 2000 + timeToWait * 2;
                    retryCount += 1;
                    setTimeout(() => {
                        deferred.resolve(this._getACRToken(AADToken, endpointName, registryURL, retryCount, waitedTime));
                    }, waitedTime);
                }
                else {
                    deferred.reject(tl.loc('CouldNotFetchAccessTokenforACRStatusCode', response.statusCode, response.statusMessage));
                }
            }
            else {
                deferred.reject(tl.loc('CouldNotFetchAccessTokenforMSIDueToACRNotConfiguredProperlyStatusCode', response.statusCode, response.statusMessage));
            }
        }, (error) => {
            deferred.reject(error);
        });
        return deferred.promise;
    }
    _getMSIAuthenticationToken(retryCount, timeToWait) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.registryURL && this.endpointName) {
                try {
                    let aadtoken = yield azure_arm_common_1.ApplicationTokenCredentials.getMSIAuthorizationToken(retryCount, timeToWait, "https://management.core.windows.net/");
                    let acrToken = yield ACRAuthenticationTokenProvider._getACRToken(aadtoken, this.endpointName, this.registryURL, retryCount, timeToWait);
                    return new registryauthenticationtoken_1.default("00000000-0000-0000-0000-000000000000", acrToken, this.registryURL, "ManagedIdentity@AzureRM", this.getXMetaSourceClient());
                }
                catch (error) {
                    tl.debug("Unable to get registry authentication token with given registryURL. Please make sure that the MSI is correctly configured");
                    throw new Error(tl.loc("MSIFetchError"));
                }
            }
            throw new Error(tl.loc("MSIFetchError"));
        });
    }
}
exports.default = ACRAuthenticationTokenProvider;
